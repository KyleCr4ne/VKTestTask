# VK Test Task
*Тестовое задания для ВКонтакте на позицию инженера машинного обучения*

## Задача

- Подготовить и проверить датасет
- Выбрать модель и обучить ее ранжировать документы по их признакам внутри поисковой сессии
- Посчитать метрику NDCG@5

## Датасет

Файл intern_task.csv

Датасет содержит записи со следующими параметрами:

- **query_id** - идентификатор поисковой сессии
- **feature_i** ($i \in [0, 143]$) - вектор фичей документа
- **rank** - ранг документа (Целочисленные значения от 0 до 4)

## Анализ датасета, предобработка данных

Проанализируем данные датасета, разделим данные на тренировочные и тестовые с учетом особенностей структуры 

[Ноутбук](./DataPreprocessingAndFeatureExtraction.ipynb)

## Модель мультиклассовой классификации

Попробуем посмотреть на данную задачу ранжирования с точки зрения мультиклассовой классификации. Так как за ранжирование документов отвечает rank, принимающий 5 значений, то попробуем спрогнозировать его значение по вектору признаков. Следовательно, в данном предположении мы не учитываем структуру датасета, а именно группировку документов по поисковой сессии. 

[Ноутбук](./MultiClassApproach.ipynb)

Данный подход позволил получить неплохие результаты по метрике NDCG@5. Однако, при более детальном рассмотрении результатов, осознаем, что модель зачастую ошибается. А высокие показатели по метрике обусловенны несбалансированностью классов. Присутсвует явное преобладание rank=0, при этом некоторые поисковые сессии вовсе не содержат документов с рангом выше 0 или же 1. А модель обучилась так, что плохо справляется с классификацией (об этом свидетельствует показатель accuracy_score). Таким образом, модель, выдавая в некоторой степени случайные значения, учитывая особенность датасета и требуемой метрики, получает неплохие результаты относительно ранжирования, но при этом совершает значимые ошибки.

## Усовершенствуем подход 

Попробуем развить наш подход с классификацией меток. Основная проблема данного подхода в том, что модель не имеет никакого представления о порядке классов, а просто классифицирует данные на равноправные классы (другими словами, как пример, модель ничего не знает о том, что метка ранга 3, находится между 2 и 4).

В таком случае, можно прогнозировать не метку класса, а вероятность того, что документ сессии имеет ранг "больше 0", "больше 1", "больше 2", "больше 3". Такой подход позволит упорядочить классы.

Для реализации такого подхода необходимо обучить четыре классификатора:

*Pr - probability*

- CLF0 : Pr(rank > 0)
- CLF1 : Pr(rank > 1)
- CLF2 : Pr(rank > 2)
- CLF3 : Pr(rank > 3)

И если теперь мы будем предсказывать не метку класса, а вероятность, то вероятность принадлежности к классу можно определить следующим образом:

- 0 : 1 - Pr(rank > 0)
- 1 : Pr(rank > 0) - Pr(rank > 1)
- 2 : Pr(rank > 1) - Pr(rank > 2)
- 3 : Pr(rank > 2) - Pr(rank > 3)
- 4 : Pr(rank > 3)

Выбирая максимальное из этих значений, получим метку класса, к которому вероятнее всего принадлежит документ




